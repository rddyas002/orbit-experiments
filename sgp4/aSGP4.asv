/*
 * File : aSGP4.c
 * Abstract:
 *       Implementation of NRossouw MSc Thesis
 *
 *  
 * Reference for SGP4 source/headers https://celestrak.com/software/vallado-sw.asp
 */


#define S_FUNCTION_NAME  aSGP4
#define S_FUNCTION_LEVEL 2

#include "simstruc.h"
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <fstream>

#include "sgp4ext.h"
#include "sgp4unit.h"
#include "sgp4io.h"
#include "mex.h"

#define TLE_FILE    "REFERENCE.TLE"

/* Global variables */
elsetrec satrec;
gravconsttype  whichconst;
static double jdm_sim_start = 0;
static char longstr1_tle[130];
static char longstr2_tle[130];  

// helper functions
static void calc_eci2ntw_dcm(const double r[3], const double v[3], double ECI2DCM);
static void crossProduct3(double a[3], double b[3], double c[3]);
static void vectorScale3d(const double a[3], const double b, double c[3]);
static void vectorAdd3d(const double a[3], const double b[3], double c[3]);
static void vectorSubtract3d(const double a[3], const double b[3], double c[3]);
static double norm3(const double a[3]);
static double dotProduct3(const double a[3], const double b[3]);
static void normaliseVector3(double v[3]);

static real_T jday(real_T yr, real_T mon, real_T day, real_T hr, real_T b_min, real_T sec){
  real_T jd;

  /*  Computes the Julian day given YY:MM:DD-hh:mm:ss format */
  /*   references    : */
  /*     vallado       2007, 189, alg 14, ex 3-14 */
  /*  ----------------------------------------------------------------------------- */
  jd = ((((367.0 * yr - floor(7.0 * (yr + floor((mon + 9.0) / 12.0)) * 0.25)) +
          floor(275.0 * mon / 9.0)) + day) + 1.7210135E+6) + ((sec / 60.0 +
    b_min) / 60.0 + hr) / 24.0;

  /*   - 0.5 * sign(100.0 * yr + mon - 190002.5) + 0.5; */
  return jd;
}

/* Function: mdlInitializeSizes ===============================================
 * Abstract:
 *   Setup sizes of the various vectors.
 */
static void mdlInitializeSizes(SimStruct *S)
{
    ssSetNumSFcnParams(S, 1);
    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) {
        return; /* Parameter mismatch will be reported by Simulink */
    }

    if (!ssSetNumInputPorts(S, 5)) return;
    ssSetInputPortWidth(S, 0, 1);
    ssSetInputPortDirectFeedThrough(S, 0, 1);
    ssSetInputPortWidth(S, 1, 1);
    ssSetInputPortDirectFeedThrough(S, 1, 1);    
    ssSetInputPortWidth(S, 2, 1);
    ssSetInputPortDirectFeedThrough(S, 2, 1);    
    ssSetInputPortWidth(S, 3, 1);
    ssSetInputPortDirectFeedThrough(S, 3, 1);    
    ssSetInputPortWidth(S, 4, 1);
    ssSetInputPortDirectFeedThrough(S, 4, 1);    

    if (!ssSetNumOutputPorts(S,3)) return;
    ssSetOutputPortWidth(S, 0, 3);
    ssSetOutputPortWidth(S, 1, 3);
    ssSetOutputPortWidth(S, 2, 1);

    ssSetNumSampleTimes(S, 1);

    /* specify the sim state compliance to be same as a built-in block */
    ssSetSimStateCompliance(S, USE_DEFAULT_SIM_STATE);

    /* Take care when specifying exception free code - see sfuntmpl_doc.c */
    ssSetOptions(S,
                 SS_OPTION_WORKS_WITH_CODE_REUSE |
                 SS_OPTION_EXCEPTION_FREE_CODE |
                 SS_OPTION_USE_TLC_WITH_ACCELERATOR);
}


/* Function: mdlInitializeSampleTimes =========================================
 * Abstract:
 *    Specifiy that we inherit our sample time from the driving block.
 */
#define BLOCK_SAMPLE    1

static void loadTLE_forSGP4(){
    FILE *infile;
    double sec,  jd, rad, tsince, startmfe, stopmfe, deltamin;
    char typerun, typeinput, opsmode;
    double ro[3];
    double vo[3];
    
    infile = fopen(TLE_FILE, "r");
    
    // Set mode variables
    opsmode = 'i';
    typerun = 'm';
    typeinput = 'v';
    whichconst = wgs84;
    
    /* Extract values */
    fgets(longstr1_tle,130,infile);
    fgets(longstr2_tle,130,infile);
    fclose(infile);
    twoline2rv(longstr1_tle, longstr2_tle, typerun, typeinput, opsmode, whichconst, 
        startmfe, stopmfe, deltamin, satrec);
    
    // call the propagator to get the initial state vector value
    sgp4 (whichconst, satrec,  0.0, ro,  vo);    
}

static void modifyTleParameters(double delta_incl, double delta_RAAN, double e, double w){
    // need to reinitialise sgp4 parameters
    satrec.inclo += delta_incl;
    satrec.nodeo += delta_RAAN;
    sgp4init(whichconst, 'i', satrec.satnum, satrec.jdsatepoch-2433281.5, satrec.bstar,
                 satrec.ecco, satrec.argpo, satrec.inclo, satrec.mo, satrec.no,
                 satrec.nodeo, satrec);    
}

static void mdlInitializeSampleTimes(SimStruct *S)
{   
    ssSetSampleTime(S, 0, BLOCK_SAMPLE);//INHERITED_SAMPLE_TIME);
    ssSetOffsetTime(S, 0, 0.0);
    ssSetModelReferenceSampleTimeDefaultInheritance(S); 
    
    const real_T year = ( mxGetPr(ssGetSFcnParam(S,0)) )[0];
    const real_T month = ( mxGetPr(ssGetSFcnParam(S,0)) )[1];
    const real_T day = ( mxGetPr(ssGetSFcnParam(S,0)) )[2];
    const real_T hour = ( mxGetPr(ssGetSFcnParam(S,0)) )[3];
    const real_T min = ( mxGetPr(ssGetSFcnParam(S,0)) )[4];
    const real_T sec = ( mxGetPr(ssGetSFcnParam(S,0)) )[5];    
      
    jdm_sim_start = jday(year, month, day, hour, min, sec)*24*60;
    
    /* Initialise SGP4 with TLE */
    loadTLE_forSGP4();
}

/* Function: mdlOutputs =======================================================
 * Abstract:
 *    
 */

static void mdlOutputs(SimStruct *S, int_T tid)
{
    double ro[3];
    double vo[3];
    
    int_T             i;
    InputRealPtrsType uPtrs = ssGetInputPortRealSignalPtrs(S,0);
    InputRealPtrsType del_incl = ssGetInputPortRealSignalPtrs(S,1);
    InputRealPtrsType del_raan = ssGetInputPortRealSignalPtrs(S,2);
    InputRealPtrsType del_e = ssGetInputPortRealSignalPtrs(S,3);
    InputRealPtrsType del_w = ssGetInputPortRealSignalPtrs(S,4);
    real_T            *y0    = ssGetOutputPortRealSignal(S,0);
    real_T            *y1    = ssGetOutputPortRealSignal(S,1);
    real_T            *y2    = ssGetOutputPortRealSignal(S,2);
    int_T             width = ssGetOutputPortWidth(S,0);

    double minutes_from_start_relative = *uPtrs[0]/60;
    double minutes_from_start_absolute = minutes_from_start_relative + jdm_sim_start;
    *y2 = jdm_sim_start;
    // compute julian day minutes from epoch to request time
    double delta_t_pred_mjd = minutes_from_start_absolute - satrec.jdsatepoch*24*60;
  //  modifyTleParameters(*del_incl[0], *del_raan[0], *del_e[0], *del_w[0]);
    sgp4(whichconst, satrec,  delta_t_pred_mjd, ro,  vo);
    
    *y0++ = ro[0];
    *y0++ = ro[1];
    *y0++ = ro[2];
    *y1++ = vo[0];
    *y1++ = vo[1];
    *y1++ = vo[2];
}

static void calc_eci2ntw_dcm(const double r[3], const double v[3], double ECI2NTW_DCM[3][3]){
    double T[3];
    double W[3];
    double N[3];
      
    T[0] = v[0];
    T[1] = v[1];
    T[2] = v[2];
    normaliseVector3(T);
    
    crossProduct3(r, v, W);
    normaliseVector3(W);
    
    crossProduct3(T, W, N);
    
    ECI2NTW_DCM[0][0]
}

static void crossProduct3(double a[3], double b[3], double c[3]) {
	c[0] = a[1] * b[2] - a[2] * b[1];
	c[1] = a[2] * b[0] - a[0] * b[2];
	c[2] = a[0] * b[1] - a[1] * b[0];
}

static double dotProduct3(const double a[3], const double b[3]) {
	return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

static void vectorScale3d(const double a[3], const double b, double c[3]) {
	c[0] = a[0]*b;
	c[1] = a[1]*b;
	c[2] = a[2]*b;
}

static void vectorAdd3d(const double a[3], const double b[3], double c[3]){
	c[0] = a[0] + b[0];
	c[1] = a[1] + b[1];
	c[2] = a[2] + b[2];
}

static void vectorSubtract3d(const double a[3], const double b[3], double c[3]){
	c[0] = a[0] - b[0];
	c[1] = a[1] - b[1];
	c[2] = a[2] - b[2];
}

static double norm3(const double a[3]) {
	return sqrt(dotProduct3(a, a));
}

static void normaliseVector3(double v[3]) {
    double norm = sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
    v[0] /= norm;
    v[1] /= norm;
    v[2] /= norm;
}

/* Function: mdlTerminate =====================================================
 * Abstract:
 *    No termination needed, but we are required to have this routine.
 */
static void mdlTerminate(SimStruct *S)
{
}


#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */
#include "simulink.c"      /* MEX-file interface mechanism */
#else
#include "cg_sfun.h"       /* Code generation registration function */
#endif
